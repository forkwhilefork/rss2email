package feedlist

import (
	"io/ioutil"
	"os"
	"strings"
	"testing"
)

// We now validate feeds when adding, so we need real feed urls
// Let's hope the bbc feed urls rarely change
var testFeed1 = "http://feeds.bbci.co.uk/news/rss.xml"
var testFeed2 = "http://feeds.bbci.co.uk/news/rss.xml?edition=uk"
var testFeed3 = "http://feeds.bbci.co.uk/news/rss.xml?edition=us"
var testFeed4 = "http://feeds.bbci.co.uk/news/rss.xml?edition=int"

// TestDummy ensures we can find a default directory
func TestDummy(t *testing.T) {

	obj := New("")

	if !strings.Contains(obj.filename, ".rss2email") {
		t.Fatalf("autogenerated filename doesn't have our expected substring")
	}
}

// TestEmpty ensures we can handle a missing file
func TestEmpty(t *testing.T) {

	obj := New("/path/does/not/exist")

	entries := obj.Entries()
	if len(entries) != 0 {
		t.Fatalf("Found error reading a missing file")
	}
}

// TestSave ensures we create a file with an entry in it.
func TestSave(t *testing.T) {

	// Create a temporary file
	file, err := ioutil.TempFile(os.TempDir(), "testsave")
	if err != nil {
		t.Fatalf("failed to make temporary file: %s", err.Error())
	}
	defer os.Remove(file.Name())

	// Create a new feed
	list := New(file.Name())
	list.Add(testFeed1)

	// Save it to disk
	err = list.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// The file should now have contents - we can reload it
	// and confirm
	updated := New(file.Name())
	found := updated.Entries()

	if len(found) != 1 {
		t.Errorf("expected one entry, found %d", len(found))
	}
	if found[0] != testFeed1 {
		t.Errorf("unexpected entry found: %s", found[0])
	}
}

// TestDelete ensures we can delete an entry from a feedlist
func TestDelete(t *testing.T) {
	// Create a temporary file
	file, err := ioutil.TempFile(os.TempDir(), "testsave")
	if err != nil {
		t.Fatalf("failed to make temporary file: %s", err.Error())
	}
	defer os.Remove(file.Name())

	// Create a new feed with two entries
	list := New(file.Name())
	list.Add(testFeed1)
	list.Add(testFeed2)

	// Save it to disk
	err = list.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// The file should now have contents - we can reload it
	// and confirm the count is as-expected
	updated := New(file.Name())
	found := updated.Entries()

	if len(found) != 2 {
		t.Errorf("expected two entries, found %d", len(found))
	}

	// Now delete the atom entry & save
	updated.Delete(testFeed1)
	err = updated.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// If the delete worked we have a feedlist with a single
	// entry present now.
	final := New(file.Name())
	if len(final.Entries()) != 1 {
		t.Errorf("expected one entry, found %d", len(found))
	}

	if final.Entries()[0] != testFeed2 {
		t.Errorf("after deletion we have an unexpected entry")
	}
}

// TestMissingHome ensures that we can find the home-directory
// of a user, even without the environment
func TestMissingHome(t *testing.T) {

	cur := os.Getenv("HOME")
	os.Setenv("HOME", "")

	obj := New("")

	if !strings.Contains(obj.filename, ".rss2email") {
		t.Fatalf("autogenerated filename doesn't have our expected substring")
	}

	// Reset
	os.Setenv("HOME", cur)
}

// TestWriteFailure tests that writing to a directory is handled,
// on Unix systems.
func TestWriteFailure(t *testing.T) {

	// We're going to try writing something to a directory
	// for which we don't have permissions.
	//
	// This is a bit horrid, and Unix-specific
	_, err := os.Stat("/proc")
	if os.IsNotExist(err) {
		t.Skip("We don't have a Unix system")
	}

	//
	// Create a feed-list and write to /proc/.rss2email
	// which will fail.  Detect that error
	//
	list := New("/proc/foo/bar")
	list.Add(testFeed1)

	// Save it to disk
	err = list.Save()
	if err == nil {
		t.Fatalf("expected an error, but got none")
	}
}

// TestDuplication ensures we don't duplicate feeds.
func TestDuplication(t *testing.T) {

	// Create a temporary file
	file, err := ioutil.TempFile(os.TempDir(), "testsave")
	if err != nil {
		t.Fatalf("failed to make temporary file: %s", err.Error())
	}
	defer os.Remove(file.Name())

	// Create a new feed
	list := New(file.Name())

	// Add the same item multiple times
	list.Add(testFeed1)
	list.Add(testFeed1)
	list.Add(testFeed1)
	list.Add(testFeed1)
	list.Add(testFeed1)
	list.Add(testFeed1)

	// Save it to disk
	err = list.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// The file should now have contents - we can reload it
	// and confirm
	updated := New(file.Name())
	found := updated.Entries()

	if len(found) != 1 {
		t.Errorf("expected one entry, found %d", len(found))
	}
	if found[0] != testFeed1 {
		t.Errorf("unexpected entry found: %s", found[0])
	}
}

// TestOrdering ensures that new additions go on the end of our list.
func TestOrdering(t *testing.T) {

	// Create a temporary file
	file, err := ioutil.TempFile(os.TempDir(), "testsave")
	if err != nil {
		t.Fatalf("failed to make temporary file: %s", err.Error())
	}
	defer os.Remove(file.Name())

	// Create a new feed with two entries.
	list := New(file.Name())
	list.Add(testFeed1)
	list.Add(testFeed2)

	// Save it to disk
	err = list.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// Load it back, and ensure the order is as expected.
	updated := New(file.Name())
	found := updated.Entries()

	if len(found) != 2 {
		t.Errorf("expected two entries, found %d", len(found))
	}
	if found[0] != testFeed1 {
		t.Errorf("unexpected entry found: %s", found[0])
	}
	if found[1] != testFeed2 {
		t.Errorf("unexpected entry found: %s", found[0])
	}

	// Now add some more.
	entries := []string{testFeed3, testFeed4}
	for _, txt := range entries {
		updated.Add(txt)
	}
	err = updated.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	// Delete a couple of entries
	updated.Delete(testFeed1)
	updated.Delete(testFeed2)
	err = updated.Save()
	if err != nil {
		t.Fatalf("failed to save feed list: %s", err)
	}

	//
	// Now reload one final time to confirm we still
	// have the entries of the list - in-order.
	//
	final := New(file.Name())
	found = final.Entries()

	for i, txt := range entries {
		if found[i] != txt {
			t.Errorf("unexpected entry found at index %d, expected: %s but got %s", i, txt, found[i+2])
		}
	}
}
